"""
XML sidecar file parser for camera metadata extraction.

Handles XML files commonly generated by professional cameras from:
- Sony (XMP, XML)
- Canon (XML)
- Blackmagic (XML)
- Panasonic (XML)
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from dataclasses import dataclass
from typing import Optional, Dict, Any
from datetime import datetime
import logging


@dataclass
class CameraMetadata:
    """Container for camera metadata extracted from XML sidecar files."""
    clip_name: str
    camera_model: Optional[str] = None
    camera_id: Optional[str] = None
    date_created: Optional[datetime] = None
    duration: Optional[float] = None  # in seconds
    codec: Optional[str] = None
    resolution: Optional[str] = None
    frame_rate: Optional[float] = None
    bitrate: Optional[str] = None
    lens: Optional[str] = None
    iris: Optional[str] = None
    shutter: Optional[str] = None
    iso: Optional[int] = None
    white_balance: Optional[str] = None
    gps_coordinates: Optional[str] = None
    reel_name: Optional[str] = None
    scene: Optional[str] = None
    take: Optional[str] = None
    raw_metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.raw_metadata is None:
            self.raw_metadata = {}


class XMLParser:
    """Parser for camera XML sidecar files."""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    def find_sidecar_file(self, video_path: Path) -> Optional[Path]:
        """
        Find XML sidecar file for a given video file.
        
        Args:
            video_path: Path to video file
            
        Returns:
            Path to XML sidecar file if found, None otherwise
        """
        base_name = video_path.stem
        parent_dir = video_path.parent
        
        # Common sidecar naming patterns
        possible_names = [
            f"{base_name}.xml",
            f"{base_name}.XML",
            f"{base_name}_M01.xml",  # Sony pattern
            f"{base_name}_M01.XML",
            f"ClipMetadata_{base_name}.xml",
            f"{base_name}_metadata.xml",
            f"{base_name}.xmp",
            f"{base_name}.XMP",
        ]
        
        for name in possible_names:
            sidecar = parent_dir / name
            if sidecar.exists():
                return sidecar
        
        # Also check for directory with same name (Sony/Canon pattern)
        sidecar_dir = parent_dir / f"{base_name}.xml"
        if sidecar_dir.is_dir():
            for xml_file in sidecar_dir.glob("*.xml"):
                return xml_file
        
        return None
    
    def parse_xml(self, xml_path: Path) -> Optional[CameraMetadata]:
        """
        Parse XML file and extract camera metadata.
        
        Args:
            xml_path: Path to XML file
            
        Returns:
            CameraMetadata object if parsing successful, None otherwise
        """
        try:
            tree = ET.parse(xml_path)
            root = tree.getroot()
            
            # Detect format based on root tag
            root_tag = root.tag.lower()
            
            if 'nonrealtime' in root_tag or 'sony' in xml_path.name.lower():
                return self._parse_sony_xml(root, xml_path)
            elif 'canon' in xml_path.name.lower() or 'cmn' in root_tag.lower():
                return self._parse_canon_xml(root, xml_path)
            elif 'blackmagic' in xml_path.name.lower():
                return self._parse_blackmagic_xml(root, xml_path)
            else:
                # Generic parser
                return self._parse_generic_xml(root, xml_path)
                
        except ET.ParseError as e:
            self.logger.error(f"Failed to parse XML {xml_path}: {e}")
            return None
        except Exception as e:
            self.logger.error(f"Unexpected error parsing {xml_path}: {e}")
            return None
    
    def _parse_sony_xml(self, root: ET.Element, xml_path: Path) -> CameraMetadata:
        """Parse Sony camera XML format."""
        metadata = CameraMetadata(clip_name=xml_path.stem)
        
        # Sony uses NonRealTimeMeta namespace
        ns = {'nrt': 'urn:schemas-professionalDisc:nonRealTimeMeta:ver.2.20'}
        
        # Extract device info
        device_elem = root.find('.//nrt:Device', ns)
        if device_elem is not None:
            metadata.camera_model = device_elem.get('modelName')
            metadata.camera_id = device_elem.get('serialNo')
        
        # Extract duration
        duration_elem = root.find('.//nrt:Duration', ns)
        if duration_elem is not None:
            try:
                # Format: HH:MM:SS:FF or seconds
                duration_str = duration_elem.get('value', '0')
                if ':' in duration_str:
                    parts = duration_str.split(':')
                    if len(parts) == 4:  # HH:MM:SS:FF
                        hours, mins, secs, frames = parts
                        metadata.duration = int(hours) * 3600 + int(mins) * 60 + int(secs)
                else:
                    metadata.duration = float(duration_str)
            except (ValueError, TypeError):
                pass
        
        # Extract video format
        video_elem = root.find('.//nrt:VideoFormat', ns)
        if video_elem is not None:
            metadata.codec = video_elem.get('codec')
            metadata.frame_rate = self._parse_frame_rate(video_elem.get('frameRate'))
        
        # Extract creation date
        created_elem = root.find('.//nrt:CreationDate', ns)
        if created_elem is not None:
            date_str = created_elem.get('value')
            metadata.date_created = self._parse_date(date_str)
        
        # Extract shooting data
        shooting_elem = root.find('.//nrt:ShootingData', ns)
        if shooting_elem is not None:
            metadata.lens = shooting_elem.get('lensModel')
            metadata.iris = shooting_elem.get('iris')
            metadata.shutter = shooting_elem.get('shutter')
            metadata.iso = self._parse_int(shooting_elem.get('iso'))
            metadata.white_balance = shooting_elem.get('whiteBalance')
        
        metadata.raw_metadata = self._extract_all_metadata(root)
        return metadata
    
    def _parse_canon_xml(self, root: ET.Element, xml_path: Path) -> CameraMetadata:
        """Parse Canon camera XML format."""
        metadata = CameraMetadata(clip_name=xml_path.stem)
        
        # Canon uses different structure
        camera_elem = root.find('.//Camera')
        if camera_elem is not None:
            metadata.camera_model = self._get_text(camera_elem, 'Model')
            metadata.camera_id = self._get_text(camera_elem, 'SerialNumber')
        
        clip_elem = root.find('.//Clip')
        if clip_elem is not None:
            metadata.duration = self._parse_float(self._get_text(clip_elem, 'Duration'))
            metadata.resolution = self._get_text(clip_elem, 'Resolution')
            metadata.codec = self._get_text(clip_elem, 'Codec')
            
            frame_rate_elem = clip_elem.find('FrameRate')
            if frame_rate_elem is not None:
                metadata.frame_rate = self._parse_float(frame_rate_elem.text)
        
        metadata.raw_metadata = self._extract_all_metadata(root)
        return metadata
    
    def _parse_blackmagic_xml(self, root: ET.Element, xml_path: Path) -> CameraMetadata:
        """Parse Blackmagic Design XML format."""
        metadata = CameraMetadata(clip_name=xml_path.stem)
        
        # Blackmagic uses simple key-value pairs
        for child in root:
            tag = child.tag.lower()
            text = child.text
            
            if 'camera' in tag and 'model' in tag:
                metadata.camera_model = text
            elif 'serial' in tag:
                metadata.camera_id = text
            elif 'duration' in tag:
                metadata.duration = self._parse_float(text)
            elif 'date' in tag or 'created' in tag:
                metadata.date_created = self._parse_date(text)
            elif 'codec' in tag:
                metadata.codec = text
            elif 'resolution' in tag:
                metadata.resolution = text
            elif 'fps' in tag or 'framerate' in tag:
                metadata.frame_rate = self._parse_float(text)
            elif 'lens' in tag:
                metadata.lens = text
            elif 'iris' in tag or 'aperture' in tag:
                metadata.iris = text
            elif 'iso' in tag or 'gain' in tag:
                metadata.iso = self._parse_int(text)
        
        metadata.raw_metadata = self._extract_all_metadata(root)
        return metadata
    
    def _parse_generic_xml(self, root: ET.Element, xml_path: Path) -> CameraMetadata:
        """Generic XML parser that extracts common fields."""
        metadata = CameraMetadata(clip_name=xml_path.stem)
        
        # Extract text from common field names
        all_text = ' '.join(elem.text or '' for elem in root.iter())
        
        # Try to find camera model
        for elem in root.iter():
            tag = elem.tag.lower()
            if 'model' in tag or 'camera' in tag:
                metadata.camera_model = elem.text
                break
        
        # Try to find duration
        for elem in root.iter():
            tag = elem.tag.lower()
            if 'duration' in tag:
                metadata.duration = self._parse_float(elem.text)
                break
        
        # Try to find date
        for elem in root.iter():
            tag = elem.tag.lower()
            if 'date' in tag or 'creation' in tag:
                metadata.date_created = self._parse_date(elem.text)
                break
        
        metadata.raw_metadata = self._extract_all_metadata(root)
        return metadata
    
    def _extract_all_metadata(self, root: ET.Element) -> Dict[str, Any]:
        """Extract all metadata as a dictionary for reference."""
        metadata = {}
        for elem in root.iter():
            if elem.text and elem.text.strip():
                tag = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
                metadata[tag] = elem.text.strip()
        return metadata
    
    def _get_text(self, parent: ET.Element, tag: str) -> Optional[str]:
        """Safely get text from an XML element."""
        elem = parent.find(tag)
        return elem.text if elem is not None else None
    
    def _parse_float(self, value: Optional[str]) -> Optional[float]:
        """Safely parse a float value."""
        if value is None:
            return None
        try:
            return float(value)
        except (ValueError, TypeError):
            return None
    
    def _parse_int(self, value: Optional[str]) -> Optional[int]:
        """Safely parse an integer value."""
        if value is None:
            return None
        try:
            return int(value)
        except (ValueError, TypeError):
            return None
    
    def _parse_date(self, date_str: Optional[str]) -> Optional[datetime]:
        """Parse date string in various formats."""
        if date_str is None:
            return None
        
        formats = [
            '%Y-%m-%dT%H:%M:%S',
            '%Y-%m-%dT%H:%M:%SZ',
            '%Y-%m-%d %H:%M:%S',
            '%Y-%m-%d',
            '%d/%m/%Y %H:%M:%S',
            '%m/%d/%Y %H:%M:%S',
        ]
        
        for fmt in formats:
            try:
                return datetime.strptime(date_str.strip(), fmt)
            except ValueError:
                continue
        
        return None
    
    def _parse_frame_rate(self, fps_str: Optional[str]) -> Optional[float]:
        """Parse frame rate string (e.g., '2398' -> 23.98)."""
        if fps_str is None:
            return None
        
        try:
            # Handle common frame rate codes
            fps_map = {
                '2398': 23.98,
                '2400': 24.0,
                '2500': 25.0,
                '2997': 29.97,
                '3000': 30.0,
                '5000': 50.0,
                '5994': 59.94,
                '6000': 60.0,
            }
            
            fps_clean = fps_str.replace('.', '').replace('p', '').replace('fps', '')
            if fps_clean in fps_map:
                return fps_map[fps_clean]
            
            return float(fps_str)
        except (ValueError, TypeError):
            return None
    
    def get_metadata_for_clip(self, video_path: Path) -> Optional[CameraMetadata]:
        """
        Convenience method to find and parse XML sidecar for a video file.
        
        Args:
            video_path: Path to video file
            
        Returns:
            CameraMetadata if sidecar found and parsed, None otherwise
        """
        sidecar = self.find_sidecar_file(video_path)
        if sidecar:
            return self.parse_xml(sidecar)
        return None
